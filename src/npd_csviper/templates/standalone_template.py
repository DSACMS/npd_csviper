"""
Standalone PostgreSQL Import Script Template for npd_CSViper

This template generates standalone Python scripts that can import CSV data
into PostgreSQL databases using pre-generated SQL scripts.
"""

import os


def generate_postgresql_script(*, csv_file_path, import_key, timestamp):
    """
    Generate PostgreSQL import script content using the standalone template.
    
    Args:
        csv_file_path (str): Full path to the original CSV file
        import_key (str): Import key derived from output directory name
        timestamp (str): Timestamp for when the script was generated
        
    Returns:
        str: Complete Python script content
    """
    
    # Calculate derived values from csv_file_path
    filename = os.path.basename(csv_file_path)
    csv_basename = os.path.splitext(filename)[0]
    
    script_content = f'''#!/usr/bin/env python3
"""
PostgreSQL CSV Import Script - Generated by npd_CSViper

This script imports CSV data into a PostgreSQL database using pre-generated SQL scripts.

Original CSV: {filename}
Generated on: {timestamp}
"""

import os
import sys
import click

# Import the shared functionality from npd_csviper package
try:
    from npd_csviper.import_executor import ImportExecutor
except ImportError:
    # Fallback for standalone scripts - add the parent directory to path
    import sys
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
    from npd_csviper.import_executor import ImportExecutor


@click.command()
@click.option('--env_file_location', type=click.Path(),
              help='Path to .env file (auto-detected if not specified)')
@click.option('--csv_file', required=True, type=click.Path(),
              help='Path to CSV file to import')
@click.option('--db_schema_name', required=True,
              help='Database schema name (can be set via DB_SCHEMA env var)')
@click.option('--table_name', required=True,
              help='Table name for the imported data (can be set via DB_TABLE env var)')
@click.option('--trample', is_flag=True, default=False,
              help='Overwrite existing table data')
@click.option('--import_only_lines', type=int, default=None,
              help='Limit import to a specific number of lines for testing (positive integer).')
def main(env_file_location, csv_file, db_schema_name, table_name, trample, import_only_lines):
    """
    Import CSV data into PostgreSQL database using pre-generated SQL scripts.
    Import CSV data into PostgreSQL database using pre-generated SQL scripts.
    
    This script was generated by npd_CSViper for the CSV file: {filename}
    """
    try:
        # Validate import_only_lines
        if import_only_lines is not None:
            if not isinstance(import_only_lines, int) or import_only_lines <= 0:
                raise click.BadParameter('Value must be a whole positive number.', param_hint='--import_only_lines')

        # Load and validate configuration
        try:
            db_config, db_schema_name, table_name, metadata, encoding = ImportExecutor.load_and_validate_config(
                env_file_location, csv_file, db_schema_name, table_name, '{csv_basename}.metadata.json'
            )
        except ValueError as e:
            if "too many values to unpack" in str(e):
                from npd_csviper.exceptions import ImportExecutionError
                raise ImportExecutionError(
                    "Configuration loading failed due to version mismatch. "
                    "This error typically occurs when the import script expects a different number of return values "
                    "from the configuration loader. Please regenerate the import scripts.",
                    script_type="PostgreSQL",
                    original_error=e
                )
            else:
                raise
        except Exception as e:
            from npd_csviper.exceptions import ImportExecutionError
            raise ImportExecutionError(
                f"Failed to load and validate configuration: {{str(e)}}",
                script_type="PostgreSQL",
                original_error=e
            )
        
        # Validate CSV header with proper encoding
        try:
            expected_columns = metadata['original_column_names']
            delimiter = metadata.get('delimiter', ',')
            quote_char = metadata.get('quote_character', '"')
            ImportExecutor.validate_csv_header(csv_file, expected_columns, encoding, delimiter, quote_char)
        except Exception as e:
            from npd_csviper.exceptions import ImportExecutionError
            raise ImportExecutionError(
                f"CSV header validation failed: {{str(e)}}",
                script_type="PostgreSQL",
                original_error=e
            )
        
        # Check debug mode
        debug_mode = db_config.get('DEBUG', '').lower() in ('true', '1', 'yes', 'on')
        if debug_mode:
            click.echo("Debug mode enabled")
        
        click.echo(f"Importing {{os.path.basename(csv_file)}} into PostgreSQL database")
        click.echo(f"Schema: {{db_schema_name}}, Table: {{table_name}}")
        
        if trample:
            click.echo("Warning: --trample flag is set. Existing table data will be overwritten.")
        
        # Execute PostgreSQL import using the shared executor
        delimiter = metadata.get('delimiter', ',')
        quote_char = metadata.get('quote_character', '"')
        ImportExecutor.execute_postgresql_import(
            db_config=db_config,
            db_schema_name=db_schema_name,
            table_name=table_name,
            csv_file=csv_file,
            trample=trample,
            create_table_sql_file='{csv_basename}.create_table_postgres.sql',
            encoding=encoding,
            import_only_lines=import_only_lines,
            delimiter=delimiter,
            quote_char=quote_char
        )
        
        click.echo("âœ“ PostgreSQL import ran successfully!")
        
    except Exception as e:
        from npd_csviper.import_executor import Colors
        click.echo(Colors.dark_red(f"Error: {{e}}"), err=True)
        sys.exit(1)


if __name__ == '__main__':
    main()
'''
    
    return script_content
